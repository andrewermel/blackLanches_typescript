# ==========================================
# ğŸš€ WORKFLOW DE CI/CD - BLACKLANCHES
# ==========================================
# Este arquivo automatiza testes e verificaÃ§Ãµes toda vez que vocÃª faz push no GitHub
# CI = Continuous Integration (IntegraÃ§Ã£o ContÃ­nua)
#
# Por que isso Ã© importante?
# - Detecta bugs automaticamente antes de ir para produÃ§Ã£o
# - Garante que todos os testes passam
# - MantÃ©m a qualidade do cÃ³digo consistente
# - Documenta que o projeto estÃ¡ funcionando corretamente

# Nome do workflow que aparecerÃ¡ no GitHub
name: CI/CD Pipeline

# ==========================================
# ğŸ“Œ QUANDO ESTE WORKFLOW EXECUTA?
# ==========================================
# Define os "gatilhos" (triggers) que ativam este workflow

on:
  # Executa quando vocÃª faz PUSH em qualquer branch
  push:
    branches:
      - '**' # '**' significa "todos os branches"

  # Executa quando alguÃ©m abre um Pull Request
  pull_request:
    branches:
      - main # Apenas PRs para a branch main
      - master
      - develop

  # Permite executar manualmente pelo GitHub (Ãºtil para testes)
  workflow_dispatch:

# ==========================================
# ğŸ› ï¸ TRABALHOS (JOBS) DO WORKFLOW
# ==========================================
# Um workflow pode ter vÃ¡rios "jobs" que rodam em paralelo ou sequencialmente

jobs:
  # ========================================
  # ğŸ“ JOB 1: VERIFICAÃ‡ÃƒO DE CÃ“DIGO
  # ========================================
  # Este job verifica a qualidade do cÃ³digo sem executar testes

  code-quality:
    # Nome que aparece na interface do GitHub
    name: ğŸ” VerificaÃ§Ã£o de Qualidade

    # Sistema operacional onde o job roda
    # ubuntu-latest = versÃ£o mais recente do Ubuntu (Linux)
    # Por quÃª? Ã‰ gratuito, rÃ¡pido e a maioria dos servidores usa Linux
    runs-on: ubuntu-latest

    # ========================================
    # PASSOS (STEPS) DO JOB
    # ========================================
    # Cada step Ã© uma aÃ§Ã£o individual executada em sequÃªncia

    steps:
      # -------------------------------------
      # PASSO 1: Baixar o cÃ³digo do repositÃ³rio
      # -------------------------------------
      # actions/checkout Ã© uma aÃ§Ã£o oficial do GitHub
      # Ela baixa seu cÃ³digo para o ambiente de execuÃ§Ã£o
      - name: ğŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v4
        # @v4 = versÃ£o 4 da aÃ§Ã£o (sempre use a mais recente)

      # -------------------------------------
      # PASSO 2: Configurar Node.js
      # -------------------------------------
      # Instala o Node.js no ambiente de execuÃ§Ã£o
      - name: ğŸŸ¢ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          # VersÃ£o do Node.js (mesma que vocÃª usa localmente)
          node-version: '20'

          # Cache de dependÃªncias = guarda node_modules para acelerar
          # Se package-lock.json nÃ£o mudou, reutiliza instalaÃ§Ã£o anterior
          cache: 'npm'

      # -------------------------------------
      # PASSO 3: Instalar dependÃªncias
      # -------------------------------------
      # Instala todos os pacotes do package.json
      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci
        # 'npm ci' Ã© mais rÃ¡pido e confiÃ¡vel que 'npm install' em CI
        # Ele usa o package-lock.json exatamente como estÃ¡

      # -------------------------------------
      # PASSO 4: Verificar formataÃ§Ã£o com ESLint
      # -------------------------------------
      # ESLint analisa o cÃ³digo procurando problemas
      - name: ğŸ¨ Verificar ESLint
        run: npm run lint --if-present
        # --if-present = nÃ£o falha se o script nÃ£o existir
        continue-on-error: true
        # continue-on-error: true = nÃ£o para o workflow se der erro
        # Ãštil quando ESLint estÃ¡ configurado mas nÃ£o Ã© crÃ­tico

      # -------------------------------------
      # PASSO 5: Verificar tipos TypeScript
      # -------------------------------------
      # TypeScript verifica se os tipos estÃ£o corretos
      - name: ğŸ”· Verificar tipos TypeScript
        run: npx tsc --noEmit
        # --noEmit = apenas verifica, nÃ£o compila nada
        # Detecta erros de tipo antes de rodar os testes

  # ========================================
  # ğŸ§ª JOB 2: TESTES
  # ========================================
  # Este job executa todos os testes da aplicaÃ§Ã£o

  test:
    # Nome do job
    name: ğŸ§ª Executar Testes

    # Sistema operacional
    runs-on: ubuntu-latest

    # ========================================
    # DEPENDÃŠNCIAS DE JOBS
    # ========================================
    # Este job SÃ“ executa se 'code-quality' passar
    # Por quÃª? NÃ£o adianta testar cÃ³digo com erros Ã³bvios
    needs: code-quality

    # ========================================
    # VARIÃVEIS DE AMBIENTE
    # ========================================
    # ConfiguraÃ§Ãµes necessÃ¡rias para os testes rodarem
    env:
      # NODE_ENV = ambiente de execuÃ§Ã£o
      NODE_ENV: test

      # JWT_SECRET = chave secreta para testes de autenticaÃ§Ã£o
      # Em produÃ§Ã£o, isso vem de secrets do GitHub (nunca comite!)
      JWT_SECRET: test-secret-key-for-ci

      # DATABASE_URL = conexÃ£o com banco de dados de testes
      # Aqui usamos um banco PostgreSQL em memÃ³ria ou mock
      # ATENÃ‡ÃƒO: Ajuste isso conforme sua estratÃ©gia de testes
      DATABASE_URL: postgresql://test:test@localhost:5432/test_db

    # ========================================
    # SERVIÃ‡OS (SERVICES)
    # ========================================
    # Containers Docker que rodam junto com o job
    # Ãštil para bancos de dados de teste
    services:
      # -------------------------------------
      # PostgreSQL para testes
      # -------------------------------------
      postgres:
        # Imagem Docker oficial do PostgreSQL
        image: postgres:15

        # VariÃ¡veis de ambiente do container
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db

        # VerificaÃ§Ã£o de saÃºde = espera o banco estar pronto
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

        # Mapeia porta do container para o host
        ports:
          - 5432:5432

    steps:
      # Mesmos passos iniciais do job anterior
      - name: ğŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸŸ¢ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      # -------------------------------------
      # PASSO NOVO: Configurar banco de dados
      # -------------------------------------
      # Roda as migrations do Prisma para criar as tabelas
      - name: ğŸ—„ï¸ Configurar banco de dados
        run: npx prisma migrate deploy
        # migrate deploy = aplica migrations sem criar novas
        # Perfeito para CI/CD
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test_db

      # -------------------------------------
      # PASSO PRINCIPAL: Executar testes
      # -------------------------------------
      - name: ğŸ§ª Executar testes
        run: npm test
        # Executa todos os 25 testes que configuramos
        # Se algum falhar, o workflow inteiro falha

      # -------------------------------------
      # PASSO OPCIONAL: Gerar relatÃ³rio de cobertura
      # -------------------------------------
      # Cobertura = quanto % do cÃ³digo estÃ¡ testado
      - name: ğŸ“Š Gerar cobertura de testes
        run: npm test -- --coverage
        continue-on-error: true
        # continue-on-error porque cobertura Ã© informativa, nÃ£o crÃ­tica

      # -------------------------------------
      # PASSO OPCIONAL: Upload da cobertura
      # -------------------------------------
      # Envia relatÃ³rio de cobertura como artefato do GitHub
      - name: ğŸ“¤ Upload de cobertura
        uses: actions/upload-artifact@v4
        if: always()
        # if: always() = roda mesmo se testes falharem
        with:
          name: coverage-report
          path: coverage/
          # Fica disponÃ­vel por 7 dias na aba Actions
          retention-days: 7

  # ========================================
  # ğŸ—ï¸ JOB 3: BUILD
  # ========================================
  # Testa se a aplicaÃ§Ã£o compila para produÃ§Ã£o

  build:
    name: ğŸ—ï¸ Build de ProduÃ§Ã£o
    runs-on: ubuntu-latest

    # SÃ³ executa se os testes passarem
    needs: test

    steps:
      - name: ğŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸŸ¢ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      # -------------------------------------
      # Compilar TypeScript
      # -------------------------------------
      - name: ğŸ”¨ Compilar TypeScript
        run: npx tsc
        # Compila todo o cÃ³digo TypeScript para JavaScript
        # Verifica se nÃ£o hÃ¡ erros de compilaÃ§Ã£o

      # -------------------------------------
      # Salvar build como artefato
      # -------------------------------------
      - name: ğŸ“¦ Salvar build
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          # O cÃ³digo compilado fica disponÃ­vel para download
          retention-days: 7

# ==========================================
# ğŸ“Œ RESUMO DO FLUXO
# ==========================================
#
# 1. VocÃª faz 'git push'
# 2. GitHub detecta e inicia o workflow
# 3. Job 'code-quality':
#    - Baixa cÃ³digo
#    - Instala dependÃªncias
#    - Verifica ESLint
#    - Verifica TypeScript
# 4. Job 'test' (se anterior passar):
#    - Sobe banco PostgreSQL
#    - Roda migrations
#    - Executa todos os testes
#    - Gera relatÃ³rio de cobertura
# 5. Job 'build' (se testes passarem):
#    - Compila para produÃ§Ã£o
#    - Salva artefatos
# 6. Resultado: âœ… ou âŒ visÃ­vel no GitHub
#
# ==========================================
# ğŸ¯ BENEFÃCIOS
# ==========================================
#
# âœ… Detecta bugs antes de chegar em produÃ§Ã£o
# âœ… Garante que testes sempre passam
# âœ… Verifica qualidade automaticamente
# âœ… Documenta que o projeto funciona
# âœ… Badge de status no README
# âœ… HistÃ³rico de todas as execuÃ§Ãµes
# âœ… 100% GRATUITO para repositÃ³rios pÃºblicos
#
# ==========================================
